package taoqz.top.结构型模式.装饰器模式;

/**
 * @Author taoqingzhou
 * @Description
 * @Date 2022/12/20
 **/
public class Readme {

    /**
     *
     * 装饰器模式：
     *      意图：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。
     *      主要解决：一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。
     *      何时使用：在不想增加很多子类的情况下扩展类。
     *      如何解决：将具体功能职责划分，同时继承装饰者模式。
     *
     *      装饰器模式主要解决继承关系过于复杂的问题，通过组合来替代继承。它主要的作用是给原始类添加增强功能。这也是判断是否该用装饰器模式的一个重要的依据。
     *   除此之外，装饰器模式还有一个特点，那就是可以对原始类嵌套使用多个装饰器。为了满足这个应用场景，在设计的时候，装饰器类需要跟原始类继承相同的抽象类或者接口。
     *
     *      第一个比较特殊的地方是：装饰器类和原始类继承同样的父类，这样我们可以对原始类“嵌套”多个装饰器类。
     * 	    第二个比较特殊的地方是：装饰器类是对功能的增强，这也是装饰器模式应用场景的一个重要特点。
     *
     *      例如 Java IO 中 InputStream（抽象类）、FileInputStream（原始类）、BufferedInputStream（装饰器）、FilterInputStream（将数据读取任务交给最终委托进来的 InputStream）
     *
     *      其中抽象类实现了读取的基本操作，原始类是一个针对文件进行读取的类，装饰器类针对原始类做了增强，添加了缓冲区，提高文件读取性能。
     *      又因为我们可以对原始类嵌套使用多个装饰器，所以装饰器类需要和原始类实现相同的类活接口，但是我们看到 BufferedInputStream类实现的是 FilterInputStream。这是因为
     *   我们抽象类中实现了默认的方法比如read，那么装饰器就必须在类中再重新实现一遍这个read方法，哪怕没有任何变动，如果不进行默认实现，那最终数据读取的任务不会传递到委托对象上，而是
     *   调用默认的read方法。比如BufferedInputStream 传递了一个 FileInputStream ，如果不实现read方法，那么会调用 InputStream的read方法，而并不是 FileInputStream类中的read
     *   方法，所以提供了一个统一的默认实现的类FilterInputStream，装饰器继承该类后，只需要关注需要增强的类即可。
     *
     *
     *  和代理模式的区别：
     *      在代码编写层面没有太大区别，都是对原始类进行增强，而区别在于，代理模式是做一些对原始类来说无关的功能，而装饰器模式是增强和原始类相关的功能。
     *
     */

}
